"""
Democratiza AI - Roteador Inteligente de LLMs
Analisa complexidade do contrato e roteia para o modelo mais eficiente
"""

from enum import Enum
from typing import Dict, Any, Optional, List
from dataclasses import dataclass
import re
import asyncio
from datetime import datetime

class ComplexityLevel(Enum):
    """N√≠veis de complexidade de contratos"""
    SIMPLES = "simples"
    MEDIO = "medio" 
    COMPLEXO = "complexo"
    ESPECIALIZADO = "especializado"

class LLMProvider(Enum):
    """Provedores de LLM dispon√≠veis"""
    GEMINI_FLASH = "gemini_flash"       # Ultra-barato - triagem r√°pida
    GROQ_LLAMA = "groq_llama"           # Mais barato - contratos simples
    GEMINI_PRO = "gemini_pro"           # Econ√¥mico - contratos m√©dios
    ANTHROPIC_HAIKU = "anthropic_haiku" # Custo m√©dio - contratos m√©dios
    ANTHROPIC_SONNET = "anthropic_sonnet" # Alto custo - contratos complexos
    ANTHROPIC_OPUS = "anthropic_opus"   # M√°ximo custo - casos especializados

@dataclass
class LLMConfig:
    """Configura√ß√£o de cada modelo LLM"""
    provider: LLMProvider
    model_name: str
    cost_per_1k_tokens: float  # Custo em USD por 1k tokens
    max_context: int           # Tamanho m√°ximo do contexto
    best_for: List[str]        # Tipos de contrato ideais
    speed: str                 # fast, medium, slow
    quality: str               # basic, good, excellent

class ContractComplexityAnalyzer:
    """Analisador de complexidade de contratos"""
    
    def __init__(self):
        # Palavras-chave que indicam complexidade
        self.complexity_indicators = {
            ComplexityLevel.ESPECIALIZADO: [
                'previd√™ncia', 'aposentadoria', 'benef√≠cio', 'pec√∫lio',
                'fus√£o', 'aquisi√ß√£o', 'incorpora√ß√£o', 'cis√£o',
                'propriedade intelectual', 'patente', 'marca',
                'joint venture', 'cons√≥rcio', 'sociedade em conta de participa√ß√£o',
                'derivativos', 'swap', 'op√ß√µes', 'futuros',
                'securitiza√ß√£o', 'factoring', 'leasing financeiro'
            ],
            
            ComplexityLevel.COMPLEXO: [
                'cl√°usula penal', 'multa compensat√≥ria', 'perdas e danos',
                'rescis√£o unilateral', 'resolu√ß√£o', 'resili√ß√£o',
                'for√ßa maior', 'caso fortuito', 'hardship',
                'arbitragem', 'media√ß√£o', 'foro de elei√ß√£o',
                'garantia real', 'hipoteca', 'penhor', 'aliena√ß√£o fiduci√°ria',
                'cess√£o de cr√©dito', 'nova√ß√£o', 'sub-roga√ß√£o',
                'sociedade limitada', 'sociedade an√¥nima', 'MEI'
            ],
            
            ComplexityLevel.MEDIO: [
                'presta√ß√£o de servi√ßos', 'fornecimento', 'distribui√ß√£o',
                'representa√ß√£o comercial', 'ag√™ncia', 'franquia',
                'loca√ß√£o comercial', 'loca√ß√£o residencial',
                'compra e venda', 'm√∫tuo', 'comodato',
                'seguro', 'financiamento', 'empr√©stimo',
                'trabalho', 'est√°gio', 'terceiriza√ß√£o'
            ],
            
            ComplexityLevel.SIMPLES: [
                'assinatura', 'mensalidade', 'plano b√°sico',
                'servi√ßo simples', 'produto', 'delivery',
                'streaming', 'aplicativo', 'b√°sico'
            ]
        }
        
        # Padr√µes que aumentam complexidade
        self.complexity_patterns = {
            'clausulas_multiplas': r'Art\.|Cl√°usula|Par√°grafo.*?¬ß',
            'valores_monetarios': r'R\$\s*[\d,.]+',
            'prazos_multiplos': r'\d+\s*(dias?|meses?|anos?)',
            'referencias_legais': r'Lei\s*n?¬∫?\s*[\d.]+|C√≥digo\s*Civil|CDC',
            'formulas_complexas': r'[\+\-\*/]\s*\d+%|[a-zA-Z]+\s*=\s*[a-zA-Z\d\+\-\*/]+',
            'multiplas_partes': r'CONTRATANTE|CONTRATADO|INTERVENIENTE|ANUENTE'
        }

    def analyze_complexity(self, contract_text: str, contract_metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """
        Analisa a complexidade de um contrato
        
        Args:
            contract_text: Texto do contrato
            contract_metadata: Metadados adicionais (tipo, valor, etc.)
            
        Returns:
            Dict com an√°lise de complexidade
        """
        text_lower = contract_text.lower()
        
        # Contadores de complexidade
        complexity_scores = {level: 0 for level in ComplexityLevel}
        found_indicators = {level: [] for level in ComplexityLevel}
        
        # 1. An√°lise por palavras-chave
        for level, keywords in self.complexity_indicators.items():
            for keyword in keywords:
                if keyword in text_lower:
                    complexity_scores[level] += 1
                    found_indicators[level].append(keyword)
        
        # 2. An√°lise por padr√µes estruturais
        pattern_scores = {}
        for pattern_name, pattern in self.complexity_patterns.items():
            matches = re.findall(pattern, contract_text, re.IGNORECASE)
            pattern_scores[pattern_name] = len(matches)
        
        # 3. An√°lise de tamanho e estrutura
        text_length = len(contract_text)
        word_count = len(contract_text.split())
        paragraph_count = len(contract_text.split('\n\n'))
        
        # 4. Score baseado em metadados
        metadata_complexity = 0
        if contract_metadata:
            # Valor do contrato
            contract_value = contract_metadata.get('valor', 0)
            if contract_value > 1000000:  # > 1M
                metadata_complexity += 2
            elif contract_value > 100000:  # > 100K
                metadata_complexity += 1
            
            # Dura√ß√£o do contrato
            duration = contract_metadata.get('duracao_meses', 0)
            if duration > 60:  # > 5 anos
                metadata_complexity += 2
            elif duration > 12:  # > 1 ano
                metadata_complexity += 1
        
        # 5. C√°lculo de complexidade final
        total_specialized = complexity_scores[ComplexityLevel.ESPECIALIZADO] * 4
        total_complex = complexity_scores[ComplexityLevel.COMPLEXO] * 3
        total_medium = complexity_scores[ComplexityLevel.MEDIO] * 2
        total_simple = complexity_scores[ComplexityLevel.SIMPLES] * 1
        
        # Score estrutural
        structural_score = 0
        if word_count > 5000:
            structural_score += 3
        elif word_count > 2000:
            structural_score += 2
        elif word_count > 500:
            structural_score += 1
        
        # Score de padr√µes
        pattern_score = sum(min(score, 3) for score in pattern_scores.values())
        
        # Score total
        total_score = (
            total_specialized + total_complex + 
            total_medium + total_simple + 
            structural_score + pattern_score + 
            metadata_complexity
        )
        
        # Determina√ß√£o do n√≠vel final
        if total_specialized >= 1 or total_score >= 15:
            final_level = ComplexityLevel.ESPECIALIZADO
        elif total_complex >= 2 or total_score >= 10:
            final_level = ComplexityLevel.COMPLEXO  
        elif total_medium >= 2 or total_score >= 5:
            final_level = ComplexityLevel.MEDIO
        else:
            final_level = ComplexityLevel.SIMPLES
        
        return {
            'complexity_level': final_level,
            'total_score': total_score,
            'breakdown': {
                'specialized_score': total_specialized,
                'complex_score': total_complex,
                'medium_score': total_medium,
                'simple_score': total_simple,
                'structural_score': structural_score,
                'pattern_score': pattern_score,
                'metadata_score': metadata_complexity
            },
            'found_indicators': found_indicators,
            'pattern_analysis': pattern_scores,
            'document_stats': {
                'word_count': word_count,
                'character_count': text_length,
                'paragraph_count': paragraph_count
            },
            'reasoning': self._get_complexity_reasoning(
                final_level, found_indicators, pattern_scores, total_score
            )
        }
    
    def _get_complexity_reasoning(
        self, 
        level: ComplexityLevel, 
        indicators: Dict[ComplexityLevel, List[str]],
        patterns: Dict[str, int],
        score: int
    ) -> str:
        """Gera explica√ß√£o da classifica√ß√£o de complexidade"""
        
        reasons = []
        
        if indicators[ComplexityLevel.ESPECIALIZADO]:
            reasons.append(f"Termos especializados detectados: {', '.join(indicators[ComplexityLevel.ESPECIALIZADO][:3])}")
        
        if indicators[ComplexityLevel.COMPLEXO]:
            reasons.append(f"Cl√°usulas complexas: {', '.join(indicators[ComplexityLevel.COMPLEXO][:3])}")
        
        if patterns['referencias_legais'] > 0:
            reasons.append(f"{patterns['referencias_legais']} refer√™ncias legais")
        
        if patterns['valores_monetarios'] > 2:
            reasons.append("M√∫ltiplos valores monet√°rios")
        
        if patterns['clausulas_multiplas'] > 10:
            reasons.append("Estrutura jur√≠dica complexa")
        
        return '; '.join(reasons) if reasons else f"Score total: {score}"

class LLMRouter:
    """Roteador principal de LLMs baseado em complexidade"""
    
    def __init__(self):
        self.complexity_analyzer = ContractComplexityAnalyzer()
        
        # Configura√ß√µes dos modelos dispon√≠veis
        self.llm_configs = {
            LLMProvider.GEMINI_FLASH: LLMConfig(
                provider=LLMProvider.GEMINI_FLASH,
                model_name="gemini-1.5-flash",
                cost_per_1k_tokens=0.00015,  # $0.00015 por 1k tokens - ULTRA BARATO
                max_context=1000000,  # 1M tokens
                best_for=["triagem inicial", "contratos padronizados", "an√°lise r√°pida"],
                speed="very_fast",
                quality="good"
            ),
            
            LLMProvider.GEMINI_PRO: LLMConfig(
                provider=LLMProvider.GEMINI_PRO,
                model_name="gemini-1.5-pro",
                cost_per_1k_tokens=0.0035,  # $0.0035 por 1k tokens
                max_context=2000000,  # 2M tokens
                best_for=["contratos m√©dios", "loca√ß√£o", "an√°lise balanceada"],
                speed="fast",
                quality="very_good"
            ),
            
            LLMProvider.GROQ_LLAMA: LLMConfig(
                provider=LLMProvider.GROQ_LLAMA,
                model_name="llama-3.1-70b-versatile",
                cost_per_1k_tokens=0.0005,  # $0.0005 por 1k tokens
                max_context=32000,
                best_for=["contratos simples", "an√°lise b√°sica", "classifica√ß√£o"],
                speed="fast",
                quality="good"
            ),
            
            LLMProvider.ANTHROPIC_HAIKU: LLMConfig(
                provider=LLMProvider.ANTHROPIC_HAIKU,
                model_name="claude-3-haiku-20240307",
                cost_per_1k_tokens=0.0015,  # $0.0015 por 1k tokens
                max_context=200000,
                best_for=["contratos m√©dios", "an√°lise jur√≠dica", "relat√≥rios"],
                speed="medium",
                quality="good"
            ),
            
            LLMProvider.ANTHROPIC_SONNET: LLMConfig(
                provider=LLMProvider.ANTHROPIC_SONNET,
                model_name="claude-3-5-sonnet-20240620",
                cost_per_1k_tokens=0.015,   # $0.015 por 1k tokens
                max_context=200000,
                best_for=["contratos complexos", "an√°lise detalhada", "riscos"],
                speed="medium",
                quality="excellent"
            ),
            
            LLMProvider.ANTHROPIC_OPUS: LLMConfig(
                provider=LLMProvider.ANTHROPIC_OPUS,
                model_name="claude-3-opus-20240229",
                cost_per_1k_tokens=0.075,   # $0.075 por 1k tokens
                max_context=200000,
                best_for=["casos especializados", "previd√™ncia", "M&A"],
                speed="slow",
                quality="excellent"
            )
        }
        
        # Mapeamento complexidade -> modelo (estrat√©gia h√≠brida otimizada)
        self.complexity_to_model = {
            ComplexityLevel.SIMPLES: LLMProvider.GEMINI_FLASH,      # Ultra-econ√¥mico
            ComplexityLevel.MEDIO: LLMProvider.GEMINI_PRO,          # Econ√¥mico + qualidade
            ComplexityLevel.COMPLEXO: LLMProvider.ANTHROPIC_SONNET, # Qualidade superior
            ComplexityLevel.ESPECIALIZADO: LLMProvider.ANTHROPIC_OPUS # M√°xima qualidade
        }
        
        # Estat√≠sticas de uso
        self.usage_stats = {
            'total_requests': 0,
            'requests_by_model': {provider: 0 for provider in LLMProvider},
            'total_cost_saved': 0.0,
            'cost_by_model': {provider: 0.0 for provider in LLMProvider}
        }

    async def analyze_complexity(self, contract_text: str, contract_metadata: Dict[str, Any] = None) -> ComplexityLevel:
        """Analisa a complexidade de um contrato"""
        analysis = self.complexity_analyzer.analyze_complexity(contract_text, contract_metadata)
        return analysis['complexity_level']

    async def route_to_best_model(self, contract_text: str, contract_metadata: Dict[str, Any] = None) -> Dict[str, Any]:
        """Roteia para o melhor modelo baseado na complexidade"""
        complexity_analysis = self.complexity_analyzer.analyze_complexity(contract_text, contract_metadata)
        complexity_level = complexity_analysis['complexity_level']
        
        selected_model = self._select_optimal_model(complexity_level, contract_metadata or {})
        config = self.llm_configs[selected_model]
        
        return {
            'provider': selected_model,
            'model': config.model_name,
            'complexity': complexity_level.value,
            'cost_per_1k': config.cost_per_1k_tokens,
            'reasoning': complexity_analysis.get('reasoning', '')
        }

    async def route_contract_analysis(
        self, 
        contract_text: str, 
        contract_metadata: Dict[str, Any] = None,
        force_model: Optional[LLMProvider] = None,
        analysis_type: str = "full"
    ) -> Dict[str, Any]:
        """
        Roteia an√°lise de contrato para o modelo mais adequado
        
        Args:
            contract_text: Texto do contrato
            contract_metadata: Metadados do contrato
            force_model: For√ßar uso de modelo espec√≠fico
            analysis_type: Tipo de an√°lise (quick, standard, full, detailed)
            
        Returns:
            Dict com roteamento e an√°lise
        """
        
        start_time = datetime.now()
        
        # 1. An√°lise de complexidade
        complexity_analysis = self.complexity_analyzer.analyze_complexity(
            contract_text, contract_metadata
        )
        
        complexity_level = complexity_analysis['complexity_level']
        
        # 2. Determinar modelo baseado na complexidade e tipo de an√°lise
        if force_model:
            selected_model = force_model
            reason = "Modelo for√ßado pelo usu√°rio"
        else:
            selected_model = self._select_optimal_model(
                complexity_level, analysis_type, len(contract_text)
            )
            reason = "Sele√ß√£o autom√°tica baseada em complexidade"
        
        # 3. Configura√ß√£o do modelo selecionado
        model_config = self.llm_configs[selected_model]
        
        # 4. Estimativa de custo
        estimated_tokens = self._estimate_tokens(contract_text, analysis_type)
        estimated_cost = (estimated_tokens / 1000) * model_config.cost_per_1k_tokens
        
        # 5. Compara√ß√£o de custo com modelo mais caro
        opus_cost = (estimated_tokens / 1000) * self.llm_configs[LLMProvider.ANTHROPIC_OPUS].cost_per_1k_tokens
        cost_saved = opus_cost - estimated_cost
        
        # 6. Atualizar estat√≠sticas
        self.usage_stats['total_requests'] += 1
        self.usage_stats['requests_by_model'][selected_model] += 1
        self.usage_stats['cost_by_model'][selected_model] += estimated_cost
        self.usage_stats['total_cost_saved'] += cost_saved
        
        routing_result = {
            'selected_model': selected_model,
            'model_config': model_config,
            'complexity_analysis': complexity_analysis,
            'routing_decision': {
                'reason': reason,
                'complexity_level': complexity_level.value,
                'analysis_type': analysis_type,
                'selection_time_ms': (datetime.now() - start_time).total_seconds() * 1000
            },
            'cost_analysis': {
                'estimated_tokens': estimated_tokens,
                'estimated_cost_usd': round(estimated_cost, 4),
                'cost_vs_opus': round(cost_saved, 4),
                'savings_percentage': round((cost_saved / opus_cost) * 100, 1) if opus_cost > 0 else 0
            },
            'recommendations': self._get_routing_recommendations(
                complexity_level, selected_model, estimated_cost
            )
        }
        
        return routing_result
    
    def _select_optimal_model(
        self, 
        complexity: ComplexityLevel, 
        analysis_type: str, 
        text_length: int
    ) -> LLMProvider:
        """Seleciona o modelo mais adequado baseado em m√∫ltiplos fatores"""
        
        # Modelo base pela complexidade
        base_model = self.complexity_to_model[complexity]
        
        # Ajustes baseados no tipo de an√°lise
        if analysis_type == "quick":
            # Para an√°lise r√°pida, usar modelo mais barato se poss√≠vel
            if complexity == ComplexityLevel.MEDIO:
                return LLMProvider.GROQ_LLAMA
            elif complexity == ComplexityLevel.COMPLEXO:
                return LLMProvider.ANTHROPIC_HAIKU
        
        elif analysis_type == "detailed":
            # Para an√°lise detalhada, usar modelo superior
            if complexity == ComplexityLevel.SIMPLES:
                return LLMProvider.ANTHROPIC_HAIKU
            elif complexity == ComplexityLevel.MEDIO:
                return LLMProvider.ANTHROPIC_SONNET
        
        # Ajuste baseado no tamanho do texto
        if text_length > 50000:  # Textos muito grandes
            if base_model == LLMProvider.GROQ_LLAMA:
                return LLMProvider.ANTHROPIC_HAIKU  # Melhor para contextos longos
        
        return base_model
    
    def _estimate_tokens(self, text: str, analysis_type: str) -> int:
        """Estima quantidade de tokens necess√°rios"""
        
        # Estimativa b√°sica: ~4 caracteres por token
        input_tokens = len(text) // 4
        
        # Tokens de output baseados no tipo de an√°lise
        output_tokens = {
            'quick': 500,
            'standard': 1500, 
            'full': 3000,
            'detailed': 5000
        }.get(analysis_type, 1500)
        
        return input_tokens + output_tokens
    
    def _get_routing_recommendations(
        self,
        complexity: ComplexityLevel,
        selected_model: LLMProvider,
        estimated_cost: float
    ) -> List[str]:
        """Gera recomenda√ß√µes sobre o roteamento"""
        
        recommendations = []
        
        if complexity == ComplexityLevel.SIMPLES and estimated_cost > 0.01:
            recommendations.append("üí° Considere an√°lise 'quick' para contratos simples")
        
        if complexity == ComplexityLevel.ESPECIALIZADO:
            recommendations.append("‚öñÔ∏è Contrato especializado detectado - usando modelo premium")
        
        if selected_model == LLMProvider.ANTHROPIC_OPUS:
            recommendations.append("üí∞ Alto custo - revisar se complexidade justifica")
        
        if selected_model == LLMProvider.GROQ_LLAMA:
            recommendations.append("‚ö° An√°lise econ√¥mica e r√°pida selecionada")
        
        return recommendations
    
    def get_usage_statistics(self) -> Dict[str, Any]:
        """Retorna estat√≠sticas de uso do roteador"""
        
        if self.usage_stats['total_requests'] == 0:
            return {"message": "Nenhuma requisi√ß√£o processada ainda"}
        
        avg_cost_per_request = sum(self.usage_stats['cost_by_model'].values()) / self.usage_stats['total_requests']
        
        model_distribution = {
            provider.value: {
                'requests': count,
                'percentage': round((count / self.usage_stats['total_requests']) * 100, 1),
                'total_cost': round(self.usage_stats['cost_by_model'][provider], 4)
            }
            for provider, count in self.usage_stats['requests_by_model'].items()
            if count > 0
        }
        
        return {
            'summary': {
                'total_requests': self.usage_stats['total_requests'],
                'total_cost_saved_usd': round(self.usage_stats['total_cost_saved'], 4),
                'average_cost_per_request': round(avg_cost_per_request, 4)
            },
            'model_distribution': model_distribution,
            'cost_efficiency': {
                'total_actual_cost': round(sum(self.usage_stats['cost_by_model'].values()), 4),
                'cost_if_all_opus': round(
                    self.usage_stats['total_requests'] * 0.075, 4
                ),
                'savings_percentage': round(
                    (self.usage_stats['total_cost_saved'] / 
                     (sum(self.usage_stats['cost_by_model'].values()) + self.usage_stats['total_cost_saved'])) * 100, 1
                )
            }
        }

# Factory function para criar inst√¢ncia do roteador
def create_llm_router() -> LLMRouter:
    """Cria inst√¢ncia configurada do roteador de LLMs"""
    return LLMRouter()